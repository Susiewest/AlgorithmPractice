class Solution:
    def add(self, a: int, b: int) -> int:
        x = 0xffffffff #python中不限制32位，设置x(32位的全1值)相与保留32位
        a, b = a&x, b&x #截断32位
        while b:
            a, b = a^b, (a&b)<<1&x #a^b为无进位和，a&b<<1是进位，每次二者相加，有新的进位则继续加，无(b为0)则结束循环
        return a if a<=0x7fffffff else ~(a^x) 
        #0x7fffffff 是最大的正数的补码, 如果大于这个数，则第一位为1，即负数。负数要32位取反，再~整体取反，这样只将32位之前的位由0变为1.符合负数的保存？
        #开始的时候我们为了获取负数 a 的补码，将 a, b 的 32 位以上全部置零了。处理完后，a,b 还是处于 32位以上都是 0 的补码状态，因此如果 a 的补码是负数（第 32位是 1），
        需要把这个补码恢复到 python 存储负数的形式，即 32位以上全部置 1~
执行用时：40 ms, 在所有 Python3 提交中击败了52.19%的用户
内存消耗：14.9 MB, 在所有 Python3 提交中击败了6.36%的用户

