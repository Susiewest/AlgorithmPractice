#首先处理n是负数的情况，转化为正数的求解
#然后统一写解法
#x^n，将n表示为2进制，即b0*2^0+b1*2^1+...
#b0 b1...表示n的二进制表示为1or为0
#x^n=x^(b0*2^0+b1*2^1+...)=x^1*b0+x^2*b1+x^4*b2+x^8*b3……

#除二进制角度，可以从二分法的思路理解
#x^n=x^(n/2)*x^(n/2)
当n是偶数，就继续二分，当n是奇数，x^n=x^(n//2)*x^(n//2)*x   这个多出来的x就要先乘入result，这个x并不是一直固定为最初的x，而是随着x的翻倍，他也在翻倍的，只是比x的翻倍慢一步。
判断是否为奇数====n&1
每次除以2====n>>1

class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n<0:
            x = 1/x
            n = -n
        result = 1
        while n:
            if n&1: #这条判断是否当前二进制位为1
                result*=x #如果为1就乘上当前位的x多少次幂
            x*=x #处理下一位二进制，x的含义翻倍
            n>>=1 #获得下一位二进制数值
        return result
执行用时：36 ms, 在所有 Python3 提交中击败了87.20%的用户
内存消耗：14.7 MB, 在所有 Python3 提交中击败了5.15%的用户

